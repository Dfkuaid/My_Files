## A

设 $f_{i,x}$ 为前 $i$ 个，得到的差为 $x$ 时的最小次数。

## B

显然每个串对应唯一的一串数字。

设 $f_{i}$ 表示前 $i$ 个字符对应的最小字符串数，直接 Hash 硬判转移即可。

## C

经典问题了属于是。可以转化为 LIS，然后用 `lower_bound()`  做到 $O(n\log n)$.

## D

暴力可以做到 $O(2^n)$.

考虑用什么不同的特点来区分所有的状态，使得可以完整表示所有状态并且得到的状态数可以接受。注意到选的物品的顺序是不被关注的，于是我们只需要关注哪些没选，判断一个状态不合法时只需要知道所有没选的物品中最小价格是否大于剩余空间，于是不妨按照最小的没选的物品最作为划分状态的依据。

于是我们先将所有的物品按照权值从小到大排序，然后 $O(n)$ 枚举最小的没选的物品，之前的物品一定都要选，然后对于剩下的物品做背包，找到所有剩余空间小于枚举的物品的情况即可。

## E

树上问题，考虑状态 $f_i$ 表示将石子放在 $i$ 上所需的最小石子数。

不难发现，对于同一个父亲的多个子树，我们一定是先处理所需石子数最多的，因为多出的石子不可替代，一定要购买，且提前购买可以再次利用。于是对于每个子树的根，依次考虑每个儿子，直接记录当前剩余的石子数贪心地添加即可。

## F

考虑一个完整的状态需要记录哪些信息：当前时间、已移动了多少次、当前在哪棵树。于是得到状态 $f_{i,j,0/1}$，$i,j,0/1$ 与上面的信息意义对应。

有转移：

$$
f_{i,j,x}=\max(f_{i-1,j,x},f_{i-1,j-1,\neg x})+v_{i,x},
$$

## G

注意到一种药对于答案的贡献只与所在时间的奇偶性有关，于是设 $f_{i,0/1}$ 为 $i$ 在偶数/奇数时间服下可得到的最大价值，转移只需要找到前面最大的与当前奇偶性不同的位置即可，显然这个可以在每次转移后 $O(1)$ 维护，于是最终时间复杂度为 $O(n)$.

## H

不难发现一定是从后向前确定，然后直接考虑用标记找到前面未被标记的数量符合要求的位置，即为这一位的答案，然后直接标记。$O(n^2)$ 可过。用二分进行查找配合线段树/树状数组修改标记数组前缀和可做到 $O(n\log n)$.

## I

~~百度翻译杀我~~

显然分成两个分别连通的部分只能是断边，而断掉某条边的答案就是下面子树大小和剩下的节点总数之差，于是直接求得每个子树的大小然后直接更新答案即可。

## J

设 $h_i$ 表示第二段以 $i$ 结尾可得到的最大答案。

考虑一个数作为第二段最后一个数时的最优选择，有且仅有两种：自己作为第二段，自己第一、第二段的选择与 $i-1$ 的选择仅有自己不同。

简单的证明一下第二种选择：假如 $i$ 前面选择的是与 $i-1$ 的选择不同的段，其贡献为 $h_{i-1}'$，此时对于 $i$ 得到最大值，那么根据假设应有 $h_{i-1}'+a_i\geq h_{i-1}+a_i$，即 $h_{i-1}'\geq h_{i-1}$，注意到 $h_{i-1}'$ 的选择一定包含 $i-1$，所以一定已 $i-1$ 结尾，这与 $h_{i-1}$ 是以 $i-1$ 结尾的最大答案矛盾，于是假设不成立。

于是我们设 $g_i$ 为前 $i$ 个数中最大的子段和，$f_i$ 为以 $i$ 结尾的最大子段和，显然应有

$$
\begin{aligned}
h_i&=\max(a_i+g_{i-1},a_i+h_{i-1}),\\
g_i&=\max_{1\leq j\leq i}\{f_j\},\\
\end{aligned}
$$

对于 $f$，我们有与上面同样的策略，即

$$
f_i=\max(a_i,a_i+f_{i-1}).
$$
