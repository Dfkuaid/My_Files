## 树上问题基本方法

- 前缀和
- 差分
- 离散化
- 差分
- 离线
- 二分
- 倍增
- 双指针
- 标记永久化
- 求 LCA
- DFS 序
- 链差分
- 简单树形 DP

## 分治树（猫树）

靠虑一个序列的分治树，对于每个节点，设当前节点维护区间 $[l,r]$ 的中点为 $m$，预处理出所有形如 $[i,mid](l\leq i \leq mid)$ 的值与 $[mid+1,j](mid+1\leq j\leq r)$，这个过程的时间复杂度为 $O(n\log n).$

对于任何区间查询 $[l,r]$，分治树上都存在一个对应区间包含 $[l,r]$，且中点 $m$ 在 $[l,r]$ 内的节点，找到此节点，将预处理的 $[l,m]$ 和 $[m+1,r]$ 的信息合并，即可得到询问的答案。

直接查找这个节点的复杂度是 $O(\log n)$，可以将序列长度扩充至 $2$ 的幂（维护区间为 $[1,2^k]$），我们考虑将这个区间建成一颗分治树，显然这是一颗满二叉树，那么，我们要找的节点必然是 $[l,l]$ 和 $[r,r]$ 的 LCA，我们采用堆式存储，即节点 $i$ 的左儿子编号为 $2i$，右儿子为 $2i+1$，观察其二进制形式，不难发现，每一个左儿子的编号相当于父结点编号左移一位，右儿子则是左移一位加一，所以代表 $[l,l]$ 和 $[r,r]$ 这两个区间的两个节点的 LCA 必然是两者编号在二进制下的最长相同前缀，至于这两点的编号是多少，我们可以在预处理时提前存储，这样，我们单次查询的时间复杂度为 $O(1).$

至于空间复杂度，考虑每一层保存的状态，每层有 $n$ 种，一共有 $\log n$ 层，故总体为 $O(n\log n)$。在实现时对于每个节点应当采用动态存储，如 ```vector``` 或指针，保证空间复杂度。

由猫树处理的过程不难发现，所维护的信息**必须满足区间可加性**。

## 树链剖分

用于处理将原本序列上的问题转到树上的情况，进行树链剖分后，链上操作与正常区间操作相同。

**树链剖分支持换根**。

## 虚树

对于一颗 $n$ 个点的树，给 $m$ 个关键点，可以构造出一颗点数为 $Θ(m)$ 且保持原树祖先关系的树，称为虚树。为了保证得到的是一颗树，原树的根始终视为关键点。

首先我们要明确一个目的——我们要用单调栈来维护一条虚树上的链。

也就是一个栈里相邻的两个节点在虚树上也是相邻的，而且栈是从底部到栈首单调递增的（指的是栈中节点 DFS 序单调递增），说白了就是某个节点的父亲就是栈中它下面的那个节点。

首先我们在栈中添加节点 。

然后接下来按照 DFS 序从小到大添加关键节点。

假如当前的节点与栈顶节点的 LCA 就是栈顶节点的话，则说明它们是在一条链上的。所以直接把当前节点入栈就行了。

假如当前节点与栈顶节点的 LCA 不是栈顶节点的话，将其连边，弹出。

假如弹出以后发现栈首不是 LCA 的话要让 LCA 入栈。再把当前节点入栈就行了。

``` cpp
/*OI-Wiki*/
inline bool cmp(const int x, const int y) { return id[x] < id[y]; }

void build() {
  sort(h + 1, h + k + 1, cmp);
  sta[top = 1] = 1, g.sz = 0, g.head[1] = -1;
  // 1 号节点入栈，清空 1 号节点对应的邻接表，设置邻接表边数为 1
  for (int i = 1, l; i <= k; ++i)
    if (h[i] != 1) {
      //如果 1 号节点是关键节点就不要重复添加
      l = lca(h[i], sta[top]);
      //计算当前节点与栈顶节点的 LCA
      if (l != sta[top]) {
        //如果 LCA 和栈顶元素不同，则说明当前节点不再当前栈所存的链上
        while (id[l] < id[sta[top - 1]])
          //当次大节点的 Dfs 序大于 LCA 的 Dfs 序
          g.push(sta[top - 1], sta[top]), top--;
        //把与当前节点所在的链不重合的链连接掉并且弹出
        if (id[l] > id[sta[top - 1]])
          //如果 LCA 不等于次大节点（这里的大于其实和不等于没有区别）
          g.head[l] = -1, g.push(l, sta[top]), sta[top] = l;
        //说明 LCA 是第一次入栈，清空其邻接表，连边后弹出栈顶元素，并将 LCA 入栈
        else
          g.push(l, sta[top--]);
        //说明 LCA 就是次大节点，直接弹出栈顶元素
      }
      g.head[h[i]] = -1, sta[++top] = h[i];
      //当前节点必然是第一次入栈，清空邻接表并入栈
    }
  for (int i = 1; i < top; ++i)
    g.push(sta[i], sta[i + 1]);  //剩余的最后一条链连接一下
  return;
}
```

## 静态树分治

静态树分治可以解决一类树上统计问题。

### 点分治

**树的重心**：若一个点删掉之后，所有连通子树的点数都不大于 $\left\lfloor\dfrac{n}{2}\right\rfloor$，则称这个点为树的重心。

存在性：从任一点开始，若不是重心则进入最大的子树，一定能找到重心。

**点分治重构树**：每次找树的重心，删掉后递归地找所有连通子树的重心。每次找到的重心与上一层的重心连边，可以构成一棵树，称为点分治重构树，树的高度为 $O(\log n)$。

注：对于任何高度为 $O(\log n)$的树，所有子树大小的和为 $O(n\log n)$。

### 边分治

分治中心为边，这样每次只合并边两侧的两个子问题，分析起来方便一点。

要保证复杂度，需要限制每个点的度数，所以**并不实用**。可以通过增加虚点来限制度数，一般限制为不大于 $3$，相当于多叉树转二叉树。

### 树上启发式合并

> **启发式合并**:合并两个数据结构时，将元素较少的数据结构的所有元素逐个插入另一数据结构。一个元素被插入时，其所在的数据结构至少扩大一倍，所以每个元素至多被插入 $\log n$ 次。

对于合并子树，直接将所有较小的子树合并到最大的子树中，与逐次启发式合并复杂度相同。这相当于树链剖分之后，将轻边对应子树的所有点逐个插入重边对应子树的数据结构。


### 链分治

每次删掉一条重链，递归地统计所有轻边子树，再统计所有经过重链的对象。递归的层数为 $O(\log n)$。

由于重链长度可以达到 $O(n)$，还需要解决一次序列上的统计问题，直接按这个过程统计通常并不方便。树上启发式合并可以看成优化了统计方法的链分治。


动态开点的线段树可以直接合并相同区间对应的节点：若某个区间只有一棵树创建了节点，则使用这个节点，否则递归合并两颗子树，更新节点信息。

合并复杂度仅与合并后减少的点数相关，减少的点数不会超过最初的总点数，所以总复杂度为 $O(n \log V)$。

### 长链剖分

把重链剖分中点数最大的子树换成高度最大的子树，就得到长链剖分。

> 注：对于这样定义的轻边，一个点到根的路径经过的轻边数量为 $O(\sqrt n)$。

对于相同深度信息可以简单合并的问题，可以将树上启发式合并的重链改为长链，只维护每个深度对应的信息。这样轻边子树的信息都合并到了其长链上，插入另一条长链时不需要遍历整个子树，总插入次数为 $O(n)$。

常用于优化以深度为状态的 DP。

## 动态树分治

动态树分治可以解决一类**带修改的树上统计问题**。

> 注：有时不带修改的相应问题可以通过 DP 解决，此时有人将动态树分治称为动态 DP。

### 动态点分治

对于点分树上的每个点，可以用数据结构维护原树中对应的连通子树中的所有点。要修改或查询某个点时，在点分树上到根的链上的点的数据结构中修改或查询。

### 动态链分治

用于 DDP。

## 线性基

线性基是向量空间的一组基，通常可以解决有关异或的一些题目。

通俗一点的讲法就是由一个集合构造出来的另一个集合，它有以下几个性质：

- 线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。
- 线性基是满足性质 1 的最小的集合。
- 线性基没有异或和为 0 的子集。
- 线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。
- 线性基中每个元素的二进制最高位互不相同。

构造线性基的方法如下：

对原集合的每个数 $p$ 转为二进制，从高位向低位扫，对于第 $x$ 位是 $1$ 的，如果 $a_x$ 不存在，那么令 $a_x=p$ 并结束扫描，如果存在，令 $p=p\text{ xor }a_i.$

``` cpp
inline void insert(ll x) {
  for (int i = 55;i + 1;i--) {
    if (!(x >> i))  continue; // x的第i位是0
    if (!p[i]){p[i] = x;break;}
    x ^= p[i];
  }
}
```

查询原集合内任意几个元素 $\text{xor}$ 的最大值，就可以用线性基解决。

将线性基从高位向低位扫，若 $\text{xor}$ 上当前扫到的 $a_x$ 答案变大，就把答案异或上 $a_x$。

为什么能行呢？因为从高往低位扫，若当前扫到第 $i$ 位，意味着可以保证答案的第 $i$ 位为 1，且后面没有机会改变第 $i$ 位。

查询原集合内任意几个元素 $\text{xor}$ 的最小值，就是线性基集合所有元素中最小的那个。

查询某个数是否能被异或出来，类似于插入，如果最后插入的数 $p$ 被异或成了 $0$，则能被异或出来。

## Link-Cut-Tree(LCT)

会单独写一篇 Blog 进行记录